<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    
    <title>n0tva1id</title>
    <meta charset="utf-8">
    
    <meta name="title" content="n0tva1id">
    <meta name="description" content>
    <meta property="og:image" content="/favicon.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/arduino-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/saki.js"></script>
</head>

<body>
  <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">n0tva1id</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
      
      
      <li class="menu-item">
        
        <a href="/" class="current-menu-item-link">Home</a>
        
      </li>
      
      
      
      <li class="menu-item">
        
        <a href="/archives" class="menu-item-link">Archives</a>
        
      </li>
      
      
      
      <li class="menu-item">
        
        <a href="/about" class="menu-item-link">About</a>
        
      </li>
      
      
      
      <li class="menu-item">
        
        <a href="/rss" class="menu-item-link">RSS</a>
        
      </li>
      
    </ul>
  </nav>
</header>
  <main class="main">
    <section class="posts">
  
  <article class="post">
    <div class="post-title">
      <a class="post-title-link" href="/2020/03/02/OpenWrt/">LEAN OpenWrt/LEDE的编译与安装（ESXi 6.7环境）</a>
    </div>
    <div class="post-content">
      
      <h2 id="在root下编译（需64位系统，LEAN推荐使用Ubuntu）"><a href="#在root下编译（需64位系统，LEAN推荐使用Ubuntu）" class="headerlink" title="在root下编译（需64位系统，LEAN推荐使用Ubuntu）"></a>在root下编译（需64位系统，LEAN推荐使用Ubuntu）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3.5 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib linux-libc-dev:i386</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/coolsnowwolf/lede</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update -a </span><br><span class="line">./scripts/feeds install -a</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make FORCE_UNSAFE_CONFIGURE=1 -j1 V=s</span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>-j1为单线程编译</p>
<p>-jN为N线程编译</p>
<p>首次编译使用多线程将有可能失败，LEAN推荐二次编译之后再使用多线程</p>
<p><strong>注：先确认curl是否安装，无curl时会使用wget，容易失败；若在虚拟机中编译，虚拟机内存必须超过1G，否则编译Go时会因内存不足失败。为了让编译时能放心不值守，建议先确认是否符合以上条件</strong></p>
<p>性能参考：</p>
<p>MacBook Pro 2018 13’’（i5-8259u，使用PD虚拟Ubuntu 18.04进行编译，单线程、首次编译纯耗时约1.5h）</p>
<h2 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h2><p>root</p>
<p>password</p>
<h1 id="安装至ESXi-6-7"><a href="#安装至ESXi-6-7" class="headerlink" title="安装至ESXi 6.7"></a>安装至ESXi 6.7</h1><h2 id="转换、上传vmdk"><a href="#转换、上传vmdk" class="headerlink" title="转换、上传vmdk"></a>转换、上传vmdk</h2><p>编译后进入<strong>lede/bin/targets/x86/64</strong></p>
<p>选取 <strong>openwrt-x86-64-combined-squashfs.img</strong></p>
<p>使用StarWind Converter 转换为ESX Server类文件</p>
<p>注意：转换后将产生两个VMDK文件。要将二者都上传至数据卷中，ESXi将只显示一个</p>
<h3 id="或（未尝试）"><a href="#或（未尝试）" class="headerlink" title="或（未尝试）"></a>或（未尝试）</h3><p>上传 <strong>openwrt-x86-64-combined-squashfs.img</strong>至数据卷</p>
<p>在控制面板中打开ESXi Shell与SSH：主机-操作-服务-打开SSH与Shell</p>
<p>进入esxi的数据卷目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /vmfs/volumes/datastore1</span><br></pre></td></tr></table></figure>

<p>使用转换命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmkfstools -i openwrt-x86-64-combined-squashfs.vmdk LeanOpenWrt_x64.vmdk -d thin</span><br></pre></td></tr></table></figure>

<h2 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h2><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>本机为3205U，选择分配1G内存、1个核心</li>
<li>可以只保留基本的VM网络，也可以先添加好直通网口</li>
<li><strong>重要：由于默认编译未选择UEFI-gpt，固件无UEFI引导，必须在虚拟机选项中将引导改为BIOS，否则无法正常引导</strong><br>之后选择原先上传的vmdk文件作为磁盘，选项默认，启动虚拟机后将自动进行初始化安装</li>
</ul>
<h2 id="配置LEDE"><a href="#配置LEDE" class="headerlink" title="配置LEDE"></a>配置LEDE</h2><p>虚拟显示Log停止滚动后，随意键入字符并回车，即可进入LEDE的命令行</p>
<p>先修改基本的LAN配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/config/network</span><br></pre></td></tr></table></figure>

<p>此时可以修改LAN口地址、选取网络适配器</p>
<p>修改完成后，进入LEDE后台登陆进行进一步的配置</p>
<h2 id="开启FTP服务"><a href="#开启FTP服务" class="headerlink" title="开启FTP服务"></a>开启FTP服务</h2><p>安装vsftpd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install vsftpd</span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>加入</p>
<blockquote>
<p>secure_chroot_dir=/root  </p>
</blockquote>
<blockquote>
<p> ftp_username=root</p>
</blockquote>
<p><strong>Tips：</strong></p>
<p>实际在系统中，直通ethx与网口x+1对应是紊乱的，需要手动尝试，暂未找到解决办法。目前怀疑是虚拟机启动之后才添加直通网卡的问题。</p>

      
    </div>
    <div class="post-meta">
      <span class="post-time">2020/03/02</span>
    </div>
  </article>
  
  <article class="post">
    <div class="post-title">
      <a class="post-title-link" href="/2020/03/01/网络折腾小记/">网络折腾小记</a>
    </div>
    <div class="post-content">
      
      <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>各房间均有一个千兆网口</li>
<li>所有房间2.4G/5G信号覆盖，且至少保证测速时能跑满运营商带宽（380M）</li>
<li>统一在一个千兆内网下（无中继）</li>
<li>实现全家透明代理或特定设备透明代理\全局代理</li>
<li>1T的家庭NAS储存，Timemachine备份、照片增量备份、私有网盘，利用群晖实现</li>
</ul>
<h2 id="现有设备"><a href="#现有设备" class="headerlink" title="现有设备"></a>现有设备</h2><ul>
<li>弱电箱-各房间的CAT5E线</li>
<li>弱电箱电源：2x双口220v插孔+2xDC2DC插孔（总功率5w)</li>
<li>千兆光猫一体机（仅单千兆出口）</li>
<li>百兆8口弱电箱交换机（带PoE）</li>
<li>电话线交换机</li>
<li>4口千兆软路由（3205u+8g+32g），带三相48wDC电源适配器</li>
<li>斐讯K2P b1版本</li>
<li>腾达AC9</li>
<li>家庭IoT设备，包括Aqara网关、各房间的开关及窗帘、温湿度传感器、人体传感器</li>
</ul>
<h2 id="需购清单"><a href="#需购清单" class="headerlink" title="需购清单"></a>需购清单</h2><ul>
<li>腾达8口千兆交换机</li>
<li>双相60w电源适配器（为了让软路由放进弱电箱）</li>
<li>1T 2.5寸pmr硬盘，直通群晖系统</li>
<li>Firetv Stick 4k</li>
</ul>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><ul>
<li><p>光猫网段192.168.1.x，软路由及下挂设备网段10.10.10.x</p>
</li>
<li><p>采用AC+AP模式，AC放入弱电箱中</p>
</li>
<li><p>光猫拨号，千兆网口作为LAN下挂软路由WAN口，光猫打开DHCP服务器，软路由WAN口为指定ip 192.168.1.x，LAN口下接千兆交换机</p>
</li>
<li><p>交换机分出各房间网线，客厅沙发侧放K2P作为主路由，同时打开2.4G与5G发射（餐厅处接有Aqara网关，需要2.4G网络）。除Kindle外、部分Iot设备外，全家所有设备均接入5G Wi-Fi 153信道 80MHZ</p>
</li>
<li><p>客厅内的K2P可以保证书房、卧室二、餐厅、客厅处跑满运营商380M带宽</p>
</li>
<li><p>卧室一与客厅相隔一个承重墙，5G仅能跑到100M左右，因此在卧室一内布置腾达AC9，接入千兆网线，仅打开5G发射且与客厅内的K2P设为同一ssid。同时为避免干扰，选用36信道 80MHZ</p>
</li>
<li><p>书房中台式电脑直接接入有线G口</p>
</li>
</ul>
<h2 id="软路由配置"><a href="#软路由配置" class="headerlink" title="软路由配置"></a>软路由配置</h2><ul>
<li>软路由上挂KoolShare LEDE系统，直通2、3网口（eth1，eth2），eth1接8口千兆交换机入家庭内网。网口1为软路由虚拟系统ESXi 6.7的管理网口（需要注意，在esxi启动后管理界面（即接入HDMI的显示界面）中，在Management Network设定中需将管理网口的eth0按D勾选（出现x标识），才可由eth0接入esxi的管理网关）</li>
<li>在LEDE中为eth1与eth0建立桥接，为的是让LAN口连接上直通网口的同时也能进入esxi后台管理（注：此时LAN口要在LEDE启动后才能启动。若LEDE系统损坏，必须换回网口1接入esxi管理界面，同时手动修改本机ip到10.10.10.x网段）</li>
<li>LEDE系统中选用openclash作为透明代理，开启Fake-ip模式，指定上游DNS为SmartDNS</li>
<li>ESXi中另运行群晖系统，用在线试用机的序列号替换（未替换MAC）半洗白，使转码功能正常使用</li>
<li>群晖中同时运行NextCloud网盘（Docker）</li>
<li>群晖中的TimeMachine服务器、hass.io服务器（将米家设备（空净、空调伴侣）接入Homekit）</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul>
<li>全家网络设备接入透明代理，可正常浏览Google、Youtube、Netflix</li>
<li>利用Clash连接v2ray，同时完成分流</li>
<li>Youtube可在高峰期看8k视频，客厅Firetv Stick 4k可以以4k@50 Dolby Vision观看Netflix（4K@60 Dolby Vison下画面失色+抖动闪烁，暂未知是否为电视HDMI2.0带宽不够）</li>
<li>全部主要使用房间（除厨房）均可在测速中达到运营商所给的宽带极限380M</li>
<li>DS Photo/Moments可以正常备份iPhone中的照片以及动态照片（自动组合）、视频</li>
<li>NextCloud网盘，同步、备份个人数据</li>
<li>Mac接入家庭内网时自动启用TimeMachine备份</li>
<li>Siri、小爱音响同时语音控制米家IoT设备，利用ios捷径设定家庭自动化场景</li>
</ul>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ul>
<li>路由器中的各个LAN口同样也是交换机，且二级交换并不影响内网结构，旁路由可以下挂在AP下</li>
<li>软路由作为旁路由时，LAN需与主路由在同一网段，同时将软路由的LAN设为静态ip，网关设置为主路由，同时要自己设定DNS（114+主路由ip）</li>
<li>启动旁路由时，有多种情况。情况一：主路由打开DHCP，设备获取ip为动态时，接入时DHCP由主路由管理，网关、dns等全部指向主路由，旁路由不参与网络活动。情况二：主路由打开DHCP，设备自己设定ip与网关、dns。此时网关、dns设定为旁路由时，网络活动为设备-&gt;旁路由-&gt;主路由-&gt;WAN，中间为二次转发。好处是某些设备不需要经过旁路由正常联网，坏处时手动设定ip较为麻烦，且在换回原状态时容易忽视DNS的恢复，导致解析Youtube时DNS争抢触发审计规则，无法观看。情况三：主路由关闭DHCP，旁路由打开DHCP，设备自动。此时设备将获取旁路由分配到的ip，并以旁路由为网关，所有设备的网络活动均为设备-&gt;旁路由-&gt;主路由-&gt;WAN。这个时候，可视旁路由为主路由下的二级路由</li>
<li>OpenClash目前有很多玄学问题，如关闭后直接无法上网，不知删除openclash是否有效。第一次安装版本可以正常检查更新下载内核，重置lede后又不行了；在配置界面保存带emoji的配置文件时，会导致路由后台失去响应，必须强制重启LEDE</li>
<li>关闭代理应在clash的控制台中选取全部流量为直连</li>
<li>Fake-ip模式下icmp会被阻断，即ping无效，不过后台界面测速正常</li>
<li>LEDE重置后的默认ip是192.168.1.1，如需修改需vi /etc/config/network，同时也可以设定LAN、WAN网口</li>
<li>LEDE也可以设定eth0为LAN，即与ESXi共用。但由于eth0被ESXi使用而无法直通，只能使用虚拟方式，网口吞吐量会略有下降，且cpu占用程度也会提高</li>
</ul>

      
    </div>
    <div class="post-meta">
      <span class="post-time">2020/03/01</span>
    </div>
  </article>
  
  <article class="post">
    <div class="post-title">
      <a class="post-title-link" href="/2020/01/14/数据结构/">数据结构</a>
    </div>
    <div class="post-content">
      
      <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="排序重点考察-gt-概念重要、选填很多来自课后习题、时间复杂度要求"><a href="#排序重点考察-gt-概念重要、选填很多来自课后习题、时间复杂度要求" class="headerlink" title="排序重点考察-&gt;概念重要、选填很多来自课后习题、时间复杂度要求"></a>排序重点考察-&gt;概念重要、选填很多来自课后习题、时间复杂度要求</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>基本概念</li>
<li>时间复杂度-&gt;最差复杂度、平均复杂度</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul>
<li>单链表</li>
<li>链表交换</li>
<li>合并</li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><ul>
<li><p>栈特点</p>
</li>
<li><p>顺序栈、链栈</p>
</li>
<li><p>队列——rear front 定义 实现</p>
<ul>
<li><p>f指向当前队列头元素的前一位置 r为队尾元素的位置</p>
</li>
<li><p>非循环队列：r-f就是队列长度</p>
</li>
<li><p>循环队列：r-f可能为负，因此要加上队列大小再对队列大小求余 就是队列中对应的元素个数</p>
<ul>
<li>即(n+r-f)%n</li>
</ul>
</li>
</ul>
</li>
<li><p>递归算法选择题：特殊值（0/1）判断调用次数</p>
</li>
<li><p>循环队列[0,m]入队，改队尾指针：rear=(rear+1)%(m+1)</p>
<ul>
<li><p>模数都是按着容量来</p>
</li>
<li><p>容量m+1，为了正确获得m以及0，应该模m+1。</p>
</li>
<li><p>rear当然=rear+1了，指针向后一个</p>
</li>
<li><p>队满条件：(rear+1)%n=front</p>
</li>
<li><p>队空条件：rear==front</p>
</li>
</ul>
</li>
</ul>
<h2 id="串、数组、广义表"><a href="#串、数组、广义表" class="headerlink" title="串、数组、广义表"></a>串、数组、广义表</h2><ul>
<li><p>KMP算法、next数组、nextval数组求法</p>
</li>
<li><p>KMP的匹配过程（失配、得配）</p>
<ul>
<li>出现失配的地方原地相对位置不动，模式串向右边走到第一个字母到失配的地方，开始自第二个字母配对</li>
</ul>
</li>
<li><p>矩阵的压缩储存-&gt;选择题，位置计算</p>
</li>
<li><p>广义表的定义与实现</p>
<ul>
<li><p>深度：括号层数（最深）</p>
</li>
<li><p>长度：元素个数</p>
</li>
<li><p>表头：第一个元素</p>
</li>
<li><p>表尾：除掉表头剩下的</p>
</li>
</ul>
</li>
</ul>
<h2 id="树、二叉树"><a href="#树、二叉树" class="headerlink" title="树、二叉树"></a>树、二叉树</h2><ul>
<li><p>树转的二叉树是唯一的</p>
</li>
<li><p>二叉树性质：n0=n2+1（度为0的节点=度为2的节点+1）、n=n0+n1+n2</p>
</li>
<li><p>树的二叉链表表示法：</p>
<ul>
<li><p>左指针firstchild右指针nextsiblings</p>
</li>
<li><p>左边指向自己的第一个孩子</p>
</li>
<li><p>右边指向自己的下一个兄弟（同层）</p>
<ul>
<li>因此根节点的nextsiblings为空</li>
</ul>
</li>
</ul>
</li>
<li><p>树定义、基本结构、深度等</p>
</li>
<li><p>树转二叉树：兄弟之间横连起来，后面的当前面的右子。根的第一个孩子是左子。唯一只有一个孩子也放左子</p>
</li>
<li><p>二叉树转森林：根连着自己的左子树成一颗 而每一个右子树自成一颗（割断）拆下来的树的右子想成siblings，对应建成一颗树<br><img src="Image.png" alt></p>
</li>
<li><p>建线索树时，要看它的指针有没有被左右子树用。如果用了，就不要在上面画线索了</p>
</li>
<li><p>由某两个序求另一个序</p>
</li>
<li><p>森林与二叉树的转换 </p>
</li>
<li><p>哈夫曼树的构造</p>
<ul>
<li><p>选取两个权最小的组合成一个树，把权之和放回原序列，重复过程、</p>
</li>
<li><p>选不选已经建成树的根都一样，最后算出来的WPL是一样的。只是看起来可能有些地方深度深一些。</p>
</li>
</ul>
</li>
<li><p>哈夫曼编码</p>
<ul>
<li>前缀编码：某个码字自己不能出现在别人的前缀里（不然别人的码译码到一半先把那个码给译出来了</li>
</ul>
</li>
<li><p>哈夫曼树 叶子n个 总节点2n-1个（只有度为0的节点和度为2的节点）</p>
</li>
<li><p>哈夫曼树不是完全二叉树（上层并不是很满）</p>
</li>
</ul>
<h2 id="期中"><a href="#期中" class="headerlink" title="期中"></a>期中</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li><p>邻接矩阵、邻接表、十字链表、临接多重表</p>
</li>
<li><p>dfs</p>
<ul>
<li>往深了走，走不通回退</li>
</ul>
</li>
<li><p>bfs</p>
<ul>
<li>辐射式扩张，一阶一阶扩张</li>
</ul>
</li>
<li><p>最小生成树</p>
<ul>
<li><p>prim适合稠密</p>
</li>
<li><p>kruskal适合稀疏</p>
</li>
<li><p>dfs生成树的高度&lt;=bfs的（dfs倾向于走的深）</p>
</li>
</ul>
</li>
<li><p>最短路（要求写矩阵的更新过程）</p>
<ul>
<li><p>dij</p>
<ul>
<li><p>选取<strong>全局路径最短</strong>的加入点集中</p>
</li>
<li><p>在下一列里更新新点对还没有在点集中的点造成的路径的影响</p>
</li>
<li><p>回到第一步</p>
<ul>
<li>在该点加入点集之前，都要一直写出它的状态。加入点集后，已经是最短路，就不用再更新了</li>
</ul>
</li>
</ul>
</li>
<li><p>floyd</p>
<ul>
<li><p>D(i)表示将<strong>第i个</strong>顶点加入路径中转点</p>
</li>
<li><p>不能到达的点记为∞</p>
</li>
<li><p>时刻记住连通性以及相应的路径长度对于D(i)言是：在加入了第i个中转点后我经由这个中转点到达的最短距离。原来的连通性不变。但不能凭空构造连通性。一切基于当前加入的这个第i点，用来更新各点间的最短距离</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑排序（判环、AOC、AOE网络）</p>
<ul>
<li><p>在有向图中选取一个无前驱节点，输出</p>
</li>
<li><p>在图中删掉该顶点以及其所有相关边</p>
</li>
<li><p>重复以上过程</p>
</li>
<li><p>判环：<strong>若所有节点都在拓扑排序出来的序列中，则不存在环</strong></p>
</li>
</ul>
</li>
<li><p>判环：dfs重复访问不行（见反例）</p>
</li>
<li><p>关键路径算法、最早最迟算法</p>
<ul>
<li><p>先求顶点的，再求边活动的</p>
</li>
<li><p>对图中所有顶点拓扑排序，求出每个事件的最早发生时间ve(i)-&gt;由源点到vi的最长路径长度（保证前序事件都完成）递推式：ve（i）=Max{ve(k)+wk,i}，ve(0）=0（源点开始的最长路）</p>
</li>
<li><p>按逆拓扑序列求出每个事件最迟发生时间vl(i）-&gt;保证不拖延后续工作，最晚最晚也要从后续工作最晚开始的时候再减掉自己工作的时间，也就是自己的最迟开始做的时间 递推式子（逆拓扑，从sink开始往回算）：vl(i)=Min{vl(k)-wi,k}, 逆拓扑的第一个也就是原拓扑的最后一个，vl(last)=ve(last）（也就是上一步最后一个算完的ve，就是这个vl的初始值）（汇点开始的最长路，值为ve(last）-最长路的路径）</p>
</li>
<li><p>求出每个活动ai最早开始时间e(i)-&gt;活动ai=&lt;vj,vk&gt;最早可以在vj完成后开始，即e(i)=ve(j)</p>
</li>
<li><p>求出每个活动ai最晚开始时间l(i)-&gt;活动ai=&lt;vj,vk&gt;最晚必须要在vk开始前减掉工期开始，即l(i)=vl(k)-wj,k</p>
</li>
<li><p>找出e(i)=l(i)的活动ai，即为关键活动。由关键活动形成的由源点到汇点的每一条路径就是关键路径，可能不止一条（l(i)-e(i)代表这个活动完成的时间松弛度。若为0，则说明这个活动必须如期完成，不然就将拖延所有的工程）</p>
</li>
</ul>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p>ASL</p>
<ul>
<li>定义：对Pi*Ci的求和，Pi表示查找某一个记录的概率（一般等概率为1/n），Ci为查找这一记录所需要的表中字与所要查找的关键字的比较次数</li>
</ul>
</li>
<li><p>顺序、折半、分块</p>
</li>
<li><p>顺序查找</p>
<ul>
<li><p>逐个扫描 ASL=1+n/2</p>
</li>
<li><p>监视哨：判定结束条件，将是否找到设置为循环中的判定，省去了查找的二次判定。</p>
</li>
<li><p>评价：</p>
<ul>
<li><p>适用顺序、链式，不管有序与否。</p>
</li>
<li><p>效率较低</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>折半查找</p>
<ul>
<li><p>折半查找使用mid=(low+high)/2的向下取整计算中点坐标</p>
</li>
<li><p>更改范围时，由mid-1更新为新的high，mid+1更新为新的low</p>
</li>
<li><p>查找失败：当low&gt;high时才失败。low=high时为最后一次判断</p>
</li>
<li><p>折半查找的判定树：</p>
<ul>
<li><p>使用二叉树描述，节点记录当前查找的中点坐标</p>
</li>
<li><p>根节点代表比较一次。树深度（由根节点=1）始算，代表相应的查找所需要的比较次数——&gt;用于计算最小比较次数</p>
</li>
<li><p>查找失败：引入外部节点，最少要有logn向下取整，最大则+1（最底下两层才可能失败）-&gt;存疑。会出现查找失败的点：子树不满的点。这类点的深度为logn或logn+1（向下取整），因此查找失败最少logn 最多logn+1</p>
</li>
<li><p>查找成功最多比较次数：最深层，logn向下取整+1（深度）</p>
</li>
</ul>
</li>
<li><p>ASL：树形结构，ASL=log(n+1)-1</p>
<ul>
<li><p>具体到某一个判定树的ASL计算：ASL=1/n*(求和（每层高度（比较次数）*当前层节点数））</p>
</li>
<li><p>实际上除了最后一行不满上面都是满的，因此就递增乘下去</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分块查找</p>
<ul>
<li><p>按索引查找，保存一个索引表，记录起始地址、起始地址到下一个起始地址里最大的关键字。</p>
</li>
<li><p>思想类似与先确定在哪个块，再在块内顺序查找（折半确认块+顺序的合成）</p>
</li>
</ul>
</li>
<li><p>二叉排序树——递归构建，左子树小于右子树</p>
<ul>
<li>具体到某一个二叉排序树的ASL计算：ASL=1/n*(求和（每层高度（比较次数）*当前层节点数））与二叉判定树形式相同</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<ul>
<li><p>调整（LL、LR、RL、RR型判断）</p>
</li>
<li><p>平衡因子为左子深度-右子深度</p>
</li>
<li><p>相应的调整法-&gt;在中序的条件下保持平衡，因此不能改变中序序列</p>
</li>
</ul>
</li>
<li><p>B-树——&gt;插入、删除，中序，等于的m叉排序树</p>
<ul>
<li><p>树中每个节点至多有m颗子树</p>
</li>
<li><p>m阶树：除根之外的所有节点内部东西要求最少「m/2  </p>
</li>
<li><p>所有非终端节点最多有m-1个关键字</p>
</li>
<li><p>3阶B树：节点内1-2个内容 4阶B树：节点内1-3个内容 </p>
</li>
<li><p>插入：m叉搜索树进入最底层进行插入，判断是否撑满，若撑满，则分裂。分裂原则：「m/2（向上取整） 处的东西拿上去（向上插入），再看看会不会满，若满则继续分裂，再把这个满的中位元素向上插入</p>
</li>
<li><p>删除：按照中序遍历的理念，删除一个点等于把其后继直接换到这个位置，之后再把这个后继删掉。删掉过程：保证这棵树的平衡。尝试各种并点、拉点、移点到相应位置。</p>
</li>
</ul>
</li>
<li><p>散列表、哈希的构造、查找、处理冲突的方法，以及ASL的计算</p>
</li>
<li><p>散列表处理冲突</p>
<blockquote>
<p>链地址法：同一位置时，用链支出去<br>线性</p>
<pre><code>二次探测法：offset：1，\-1，4，\-4，9，\-9...不会出现二次聚集（堆积），但不一定能找到不冲突的地址
线性探测法：offset：1，2，3，4，5，6...会出现二次聚集（堆积）（用了别人的空间导致别人本来的地方用不了要继续找。</code></pre></blockquote>
</li>
<li><p>ASL的计算：</p>
<ul>
<li><p>线性</p>
</li>
<li><p>成功：总共记录的个数</p>
</li>
<li><p>失败：散列函数取值的个数，并且要在散列函数所有取值对应的格子一个一个算。空的话一次比较就失败了，非空的话还得一路比到空为止。判空/等也是一次比较</p>
</li>
<li><p>链：</p>
</li>
<li><p>成功：n层的个数*n的求和</p>
</li>
<li><p>失败：还是从一一对应开始算，有值的地方要多判一次</p>
</li>
</ul>
</li>
</ul>
<h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><ul>
<li><p>内部排序：</p>
</li>
<li><p>时间复杂度</p>
</li>
<li><p>插入排序：</p>
<ul>
<li><p>直接插入</p>
<ul>
<li><p>n2</p>
</li>
<li><p>扑克牌理牌</p>
</li>
<li><p>将排序好的序列放在数列前部，对在序列后紧接者往前寻找插入位置（涉及到大量后移位过程）</p>
</li>
<li><p>稳定，链表则移动指针</p>
</li>
<li><p>适用初始记录基本有序、n小</p>
</li>
</ul>
</li>
<li><p>折半插入</p>
<ul>
<li><p>n2</p>
</li>
<li><p>在前面查找位置的过程中使用折半法</p>
</li>
<li><p>稳定</p>
</li>
<li><p>使用折半则无法使用链结构</p>
</li>
<li><p>适合初始记录无序、n大</p>
</li>
</ul>
</li>
<li><p>希尔排序</p>
<ul>
<li><p>n1.3</p>
</li>
<li><p>将间隔为increment的数组合成为一组，每次在组内相对排出有序</p>
</li>
<li><p>跳跃式移动导致不稳定</p>
</li>
<li><p>增量值表内的值应互质 且最后一个一定是1</p>
</li>
<li><p>适合初始记录无序、n大</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>交换排序：</p>
<ul>
<li><p>冒泡：</p>
<ul>
<li><p>n2</p>
</li>
<li><p>一把二叉叉子，每次选两个（位置+1而不是+2），若逆序则调换一下，为一趟（像起泡）一趟完毕后最后一个位置为比较出来的当前趟元素中的最大值</p>
</li>
<li><p>下一趟把这个最大值踢掉，再执行起泡，选择出次大值，….</p>
</li>
<li><p>稳定（相同序不交换）</p>
</li>
<li><p>链式可用</p>
</li>
<li><p>平均性能比直接插排差</p>
</li>
</ul>
</li>
<li><p>快排：</p>
<ul>
<li><p>最好nlogn最差n2（已经有序的情况）</p>
</li>
<li><p>思想：取pivotkey （一般为第一个。特殊情况，比如按某值划分两类，则选那个值），两个指针。</p>
</li>
<li><p>右往左扫，扫到一个比枢轴小的，与枢轴交换位置</p>
</li>
<li><p>左往右扫，扫到一个比枢轴大的，与之前的空位交换位置…</p>
</li>
<li><p>完成一趟排序，枢轴的左边都比枢轴小，右边都比枢轴大</p>
</li>
<li><p>再对左边、右边的子表选取各自枢轴，递归进行快排</p>
</li>
<li><p>考代码</p>
</li>
<li><p>空间：使用栈，最好空间复杂度logn最差n</p>
</li>
<li><p>记录移动并非按顺序、次位移动，不稳定</p>
</li>
<li><p>上界下界，顺序结构</p>
</li>
<li><p>平均最快，适合大量、无序样本</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选择排序：（用swap，区别插入排序）</p>
<ul>
<li><p>简单选择：</p>
<ul>
<li><p>n2</p>
</li>
<li><p>前面储存排序结果。每次从未排序序列中选择一个最小的，加入已排序队列中</p>
</li>
<li><p>加入方法：已排序队列后一位与找到的最小的swap，这样已排序队列长度自然+1</p>
</li>
<li><p>稳定（使用交换方法不稳定）</p>
</li>
<li><p>可以用链</p>
</li>
<li><p>移动次数较少（用swap而不是迁移。因此移动代价大时，比直接插排快）</p>
</li>
</ul>
</li>
<li><p>树型选择：锦标赛树、胜者晋级、即二者的parent记录赢家</p>
</li>
<li><p>堆：</p>
<ul>
<li><p>nlogn</p>
</li>
<li><p>堆的性质：节点的值比其孩子的值都大（小）-&gt;大根（小根）</p>
</li>
<li><p>建初始大根堆：（本质：从最小的子树开始调整起，逐步逐步调整更大的子树（更前的），最后完成整个树调整为堆）先层序出一个完全二叉树 以大根堆为例：由于所有序号&gt;n/2的都是叶子，叶子都是堆，因此从序号n/2的点（也就是最后一个<strong>非叶子（非终端）</strong>节点）开始往前看，即调整到序号为0的节点。调整原则：看当前节点+其子树是否构成堆，不构成则进行调整（写题）</p>
</li>
<li><p>调整堆：把<strong>子根中大的优先换上来</strong>。不然换个小的上来，它还是比另一个子来的小，不就没用了？（调整的最终目的是把最大的浮上来到根，因此尽量选大的交换），当出现不合顺序的子节点时，交换根与子节点，再继续递归地判断</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* 排序过程（大根堆）：把根和当前最后一个节点交换，之后最后一个节点成为根，再把原根（现在是最后一个节点）删掉（用虚线连接，删掉后不参与堆，但要保持结构），对这个新的东西进行调整成为大根堆。换完之后就看倒数第二个节点...与根交换的节点一直往前走，直到根

* 不稳定、用顺序

* 记录数多时高效</code></pre><ul>
<li><p>归排</p>
<ul>
<li><p>2路归并进行「logn次</p>
</li>
<li><p>稳定</p>
</li>
<li><p>可用于链表</p>
</li>
<li><p>空间复杂度最高，n</p>
</li>
</ul>
</li>
<li><p>基数排序：按各位权逐步排</p>
</li>
</ul>
<h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><ul>
<li><p>IO次数计算、初始归并段（有序）</p>
<ul>
<li><p>外部排序总时间：初始归并段数 x <em>t_innersort+总io次数 x tio+归并趟数（可能需要拆分）x utmg。</em></p>
</li>
<li><p>例：10000个记录的文件，每个物理块200个记录，缓冲区可以放5个物理块</p>
<ul>
<li><p>告诉缓冲区大小为1000的作用：初始归并段大小就是缓冲区大小</p>
</li>
<li><p>计算机按物理块对文件读写，以读为例，一次200个，则每次读有50次，同理写也有50次。即对于一个10000大小的文件，一次归并的io就需要100次（默认当所有块进来都参与归并）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="Image1.png" alt></p>
<ul>
<li><p>归并时并不在意内存</p>
</li>
<li><p>多路平衡归并的实现</p>
</li>
<li><p>置换选择排序：增加初始归并段的大小</p>
<blockquote>
<p>将待分段序列加进缓冲区，取最小的进入段区，补充缓冲区，取缓冲区中大于段区的最小元素再加入段区，如此循环到缓冲区无法再往段区中加入元素，则补一个分隔符，形成一个段。<br>败者树：见课本p265。初始文件进入缓冲区时，由角标最大的开始进入，而且一开始进来的段号为1。节点记录的是其左右子树中比赛后败者的角标（叶子节点小方框顶上那个）。指向根节点的是当前这一轮比较的胜者，也就是要加入FO中的值。对于胜负比较，段号小者为胜者，段号相同时数字小者为胜者（因为要选进FO里，应该取小的。而段号大的你得留在败者树供后面的比较用，你不能赢，不然你就进去FO（这个时候还不是你应该待的段）了）</p>
</blockquote>
</li>
<li><p>最佳归并树——k叉哈夫曼树、m个段 （m-1）mod（k-1）=0  补段：补(k-1)-(m-1)mod(k-1)个段</p>
<ul>
<li>补段实际上就是补充长度为0的序列（权为0的点），把它加进初始序列再开始建树</li>
</ul>
</li>
<li><p>IO计算：WPL*2</p>
</li>
</ul>
<h2 id="有关树型排序"><a href="#有关树型排序" class="headerlink" title="有关树型排序"></a>有关树型排序</h2><p>中序最常用：左根右</p>
<p>某一节点的前驱：左子树最右下节点</p>
<p>某一节点的后继：右子树的最左下节点</p>
<p>（都是由中序的性质得到的）</p>
<p>--&gt;在B树中的删除、二叉排序树中的删除、中序线索树中都使用了这一个思想。</p>

      
    </div>
    <div class="post-meta">
      <span class="post-time">2020/01/14</span>
    </div>
  </article>
  
</section>

<p class="license">本站文章使用 CC BY-NC-SA 4.0 许可证</p>
  </main>
</body>

</html>